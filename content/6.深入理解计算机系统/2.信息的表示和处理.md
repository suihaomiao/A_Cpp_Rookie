# 信息的表示和处理
本章研究三种重要的数字表示：**无符号数**基于传统的二进制表示法，表示大于或者等于零的数。**补码**表示有符号整数的常见方式。**浮点数**表示实数的科学记数法的以2为基数的版本，上述两种表达能计量有限范围的精确数字（整数在计算机系统中均为精确表示），浮点数能表示范围很大的数，但是是一种近似表达。

## 信息存储
### 十六进制表示法
目前人类社会采用更多的是十进制，即数字逢十进一，一位上仅可能出现0-9.计算机系统中均采用二进制，即逢二进一，一位上仅可能出现0和1.十六进制是方便人类认识二进制的一种补充进制，仅存在于我们理解，计算机在运行时，均将其翻译成二进制。
理解十六进制和二进制时，需将四位二进制数计算成一个数；其次，一个字节由8位二进制组成，因此两位十六进制同样也表示成一个字节。
**该项很好理解，在这就不展开学习了**

### 字数据大小
每台计算机都有一个字长(word size)，指明指针数据的标称大小(nominal size).简单来说，就是指针能表示的范围大小。
因为虚拟内存是按照这样的字长来编码的，所以字长表示虚拟内存中所能访问到的最大值。对于一个字长为w的系统来说，他能访问的到的最大内存为2^w-1；
目前大量的出现了64位和32位系统，即其中的数字表示字长。但是通常来说，32位系统编译的程序不能再64位上运行，而64位系统编译的程序可以在32位系统上运行，通过以下方式：
`linux > gcc -m32 prog.c`
表示让编译器生成一个32位系统的程序。
同样的，也可以指定生成64的程序，这样的程序不能放在32位系统上运行
`linux > gcc -m64 prog.c`

| C声明 |C声明 | 字节数 |字节数 | 
|-------|-------|--|--|
| 有符号|无符号| 32位| 64位|
|char| unsinged char | 1 |1|
|short| unsinged short|2|2|
|int |unsinged int|4|4|
|long |unsinged long|4|8|
|int32_t|uint32_t|4|4|
|int64_t|uint64_t|8|8|
|char *||4|8|
|float||4|4|
|double||8|8|
上表列举了C语言中，常用的数据类型及其在不同位系统中的字节大小。
注意几点：
- 指针类型跟指向的数据大小无关，仅跟系统字长有关，即在32位系统中占4字节，在64位系统中占8字节
- long在32位系统为4字节，在64位系统中卫8字节。（所以在32位系统中long和int的区别在哪？）
- 后面为了开发方便，又在C语言中添加了int32_t和int64_t的数据类型，这样不管在32位和64系统中，占用的字节数均是一样的。

### 寻址和字节顺序
在实际的运行中，CPU在处理多字节的程序对象时，需要两件事：1、这个对象的地址是什么；2、以及在内存中如何排列这个字节。
第一件事很好理解，就像我需要找你家，需要知道你家地址一样。CPU需要知道该对象的地址才能去访问获取数据，CPU通过指针变量或者变量名可获取到对象的地址。
第二件事也很好理解，我知道了你家地址，我同样需要知道你家的大门往那边开，走到背面是进不去你家的。
第二件事衍生出了一个很重要的概念，大端(big endian)和小端(little endian)
即一段内存如何排列的问题，例如`12345`，在十六机制中（此处用十六进制来代替二进制，希望能熟悉此种表示方式）为`0x3039`,当变量被声明为int类型后，占用4字节内存，在内存中，大端和小端的表示方式如下：
大端：
`00003039`=`3039`
小端：
`39300000`=`3930`
注意到，30和39,30才是高地址，39是低地址。
大端小端的区别是：
当最高有效字节在最前面时，此为大端表示；当最低有效字节在最前面时，此为小端表示；在该例子中，39是最低地址，30是次低地址，剩下的高位均由0补齐。

对于大多数程序员来说，内存中具体的字节排列顺序不会产生影响，但有些时候，会造成困扰：
1. 在不同的类型的机器中通过网络传输二进制数据时，如一个小端机生产的二进制数据，通过网络发送给了大端机，接受数据时会造成解读错误。当然，为了避免此种情况，网络应用程序书写必须遵守已建立的关于字节顺序的规则。此规则在后续的学习中会介绍到
2. 在阅读内存中的数据时，大端和小端会产生影响，例如上述的例子`3039`或者`3930`会解读出不同的数据。
3. 当编写规避正常的数据类型的程序时，即在C语言中常常通过强制类型转换或者联合(union)来允许一个数据类型来表达另一个数据类型，而这种数据类型和创建时的数据类型不同。具体代码见/code/2.1.3
```C
typedef unsigned char *byte_pointer;

void show_bytes(byte_pointer start, size_t len)
{
    size_t i;
    for (i = 0; i < len; ++i)
    {
        printf(" %.2x", start[i]);
    }
    printf("\n");
}
```
简单来说，即通过传入数据的地址来打印出该内存中的值。可想而知，在大端和小端系统中打印出的值肯定不一样。使用的腾讯云服务器中，传入12345的整数，打印出来的是39300000，可知这是一个小端机。

### C语言中的位运算
C语言中可以按照位进行布尔运算，即|（或），&（与），^（异或）三种运算；
学过基础的C语言或者数字电路的已经很熟悉这些操作了。
这里强调一点，^异或操作。异或操作的应用比较多，其中包括交换两个变量的值：
```C
void inplace_swap(int *x, int *y){
    *y = *x ^ *y; 
    *x = ^y ^ ^x; // *x = 原来的*y
    *y = *y * ^x; // *y = 原来的*x
}
//该方法应用的是 (a ^ b) ^ a = b;
//^异或操作会将两个变量的信息都包含进去，可以用一个变量推算出另一个变量的值。
//该方法被用到简单的数据备份领域中
```
位运算还有一个常用的场景是掩码运算，即对于x=0x89abcdef这个变量而言，需要挑选出最低地址的字节，可以让x&y，其中y=0x000000ff,这样x = 0x000000ef.
详细见练习题2.12，/code/example2.12

### C语言中的逻辑操作
逻辑操作与位运算符号相似，容易弄混淆。
逻辑与：&&
逻辑或：||
逻辑非：!
这里在C语言书写时，频繁用到，不再详细解释了；
值得注意的一点是，在处理逻辑时的特殊情况：
```C
int p = 1;
void logic(){
    if(p > 0 || ++p)
        return;
}
```
这里的++p不会执行，因为p>0满足情况下，操作系统会认为||条件下已经满足，直接返回。
**原理在于，程序在执行时，对于逻辑运算是从左到右，一旦发现满足逻辑或者不满足逻辑，会不再继续判断。**

### C语言中的移位操作
移位操作是非常有用的操作符，<<是左移操作，>>是右移操作。
对于左移操作时，高地址的符号将被消除，低地址空缺的部分将会用0填补。
右移操作比较特殊：
对于有符号数而言，右移后，高地址位将会用原本的高地址代替，称为算术右移
对于无符号数而言，右移后，高地址为将会用0代替，称为逻辑右移
区别在于，如果该数小于0，即最高位永远是1，右移后将会用1代替空缺的部分。
补充一点：
C语言中的左移和右移位数不会限制，即如果是个int只有32位，但是移动了33位，

## 整数表示
整数的类型见第一章
### 无符号整数表示
这个比较简单，将内存中的0/1的位数进行2的指数累加即可。
例如`0101`表示的无符号数为0*2^3 + 1*2^2 + 0*2^1 + 1*2^0=5;
无符号数表示的范围即为：0-2^w-1,w是数据的长度

### 补码编码
在计算机中，有符号数均以补码的形式存储。补码在解释在整数时，将最高位解释成符号位，其他位和无符号解释相同
例如`0101`表示的有符号数为-0*2^3 + 1*2^2 + 0*2^1 + 1*2^0=4+1=5;
例如`1011`表示的有符号数为-1*2^3 + 0*2^2 + 1*2^1 + 1*2^0=-8+2+1=-5;
有符号数表示的负数范围：-2^(w-1)-0;
有符号数表示的正数范围：0-2^(w-1)-1;

补充：
有符号数还有两种标准的表示方法：
反码：反码表示和补码相似，只是最高位计算时是-(x)*(2^(w-1)-1)
例如`1011`表示的有符号数为：-1*(2^3-1) + 0*2^2 + 1*2^1 + 1*2^0 = -7+2+1=-4;
原码：原码表示有符号数，将最高位视为符号位即最高位为1即为负数，反之则为整数
例如`1011`表示的有符号数为：-(0*2^2 + 1*2^1 + 1*2^0) = -(2+1) = -3;
这两种方式对于0都有奇怪的现象，即0有两种表示-0和+0，但其实在数学定义上-0和+0都是0；
**现在的计算机都不采用上述两种方式来表示有符号数，均采用补码形式表示有符号数（整数）。在浮点数上，我们可以看到采用原码形式表示。**

###  



